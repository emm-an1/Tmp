def brownian_bridge(p0, pT, n, sigma=0.01, match_vol=True):
    """
    Generate a Brownian bridge from p0 to pT.
    
    Parameters:
        p0: starting price
        pT: ending price  
        n: number of steps (returns n+1 points)
        sigma: target per-step return volatility
        match_vol: if True, rescale path to match target vol exactly
    
    Returns:
        numpy array of length n+1
    """
    if p0 <= 0 or pT <= 0:
        raise ValueError("Prices must be positive")
    
    t = np.linspace(0, 1, n + 1)
    dW = np.random.randn(n)
    W = np.concatenate([[0], np.cumsum(dW)])
    bridge = W - t * W[-1]
    
    path = p0 + (pT - p0) * t + sigma * p0 * bridge
    
    if match_vol:
        rets = np.diff(path) / path[:-1]
        realized_vol = rets.std()
        if realized_vol > 1e-10:
            # Rescale the noise component only
            noise = path - (p0 + (pT - p0) * t)
            noise *= sigma / realized_vol
            path = p0 + (pT - p0) * t + noise
    
    path = np.abs(path)
    path[0], path[-1] = p0, pT
    
    return path
