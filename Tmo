# =============================================================================
# RESIDUAL DIAGNOSTICS (LAST / FULL WINDOW)
#   Refit the final expanding-window PCA + regression and plot residual diagnostics
# =============================================================================

import statsmodels.api as sm
from statsmodels.graphics.gofplots import qqplot
from statsmodels.tsa.stattools import acf

# ---- Refit using the final date (same logic as your loop, but for the full sample up to last date)
final_date = dates[-1]

window_data = df.loc[:final_date, PCA_COLUMNS].values
pca_final = PCA(n_components=N_COMPONENTS)
scores_final = pca_final.fit_transform(window_data)

# Optional: align sign with your stored last components (if you want consistency with your time series)
# If you kept prev_components from the loop, you can align:
try:
    for j in range(N_COMPONENTS):
        if np.dot(pca_final.components_[j], prev_components[j]) < 0:
            pca_final.components_[j] *= -1
            scores_final[:, j] *= -1
except NameError:
    pass

y_final = df.loc[:final_date, Y_COLUMN].values
X_final = sm.add_constant(scores_final)
model_final = sm.OLS(y_final, X_final).fit()

fitted = model_final.fittedvalues
resid = model_final.resid

resid_s = pd.Series(resid, index=df.loc[:final_date].index, name="residual")
fitted_s = pd.Series(fitted, index=df.loc[:final_date].index, name="fitted")

# ---- Residual summary series (optional)
std_resid_s = (resid_s - resid_s.mean()) / resid_s.std(ddof=1)

# =============================================================================
# PLOT RESIDUALS
# =============================================================================

fig, axes = plt.subplots(2, 3, figsize=(16, 9))

# (1) Residual time series
ax = axes[0, 0]
resid_s.plot(ax=ax)
ax.set_title("Residuals (time series)")
ax.axhline(0, color="k", alpha=0.3)

# (2) Residual vs fitted
ax = axes[0, 1]
ax.scatter(fitted_s.values, resid_s.values, s=10, alpha=0.6)
ax.set_title("Residuals vs Fitted")
ax.set_xlabel("Fitted")
ax.set_ylabel("Residual")
ax.axhline(0, color="k", alpha=0.3)

# (3) Histogram of residuals
ax = axes[0, 2]
ax.hist(resid_s.values, bins=40)
ax.set_title("Residual histogram")
ax.set_xlabel("Residual")

# (4) Q-Q plot
ax = axes[1, 0]
qqplot(resid_s.values, line="45", ax=ax)
ax.set_title("Q-Q plot (residuals)")

# (5) ACF of residuals
ax = axes[1, 1]
acf_vals = acf(resid_s.values, nlags=min(40, len(resid_s) - 1), fft=True)
ax.stem(range(len(acf_vals)), acf_vals, basefmt=" ")
ax.set_title("ACF of residuals")
ax.set_xlabel("Lag")
ax.axhline(0, color="k", alpha=0.3)

# (6) Rolling residual volatility (optional)
ax = axes[1, 2]
roll = 52 if FREQUENCY == "weekly" else (252 if FREQUENCY == "daily" else 12)
resid_s.rolling(roll).std().plot(ax=ax)
ax.set_title(f"Rolling residual volatility ({roll} obs)")
ax.set_ylabel("Std(residual)")

plt.tight_layout()
plt.show()

# Optional: print key stats
print(model_final.summary())