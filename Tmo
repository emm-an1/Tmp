import numpy as np
import pandas as pd

from .ScalingNode import ScalingNode
from .WeightedSumNode import WeightedSumNode


class CorrAdjustedUVScalingNode(ScalingNode):
    """
    Scales predecessor to unit volatility using correlation-adjusted risk.
    
    multiplier = 1 / sqrt(w' * Corr * w)
    
    Where:
    - w = weights from predecessor WeightedSumNode
    - Corr = rolling correlation matrix of predecessor's predecessor pnls
    """
    
    def __init__(self, name: str, predecessors: list[str], years: float = 5):
        """
        Args:
            name: Node name
            predecessors: List with single predecessor name (must be WeightedSumNode)
            years: Rolling window in years (default 5)
        """
        # Call parent with multiplier=None (we compute it)
        super().__init__(name=name, predecessors=predecessors, multiplier=None)
        
        if not isinstance(self.predecessor, WeightedSumNode):
            raise ValueError("CorrAdjustedUVScalingNode predecessor must be WeightedSumNode")
        
        self._years = years
        self._window = int(years * 252)
        self._computed_multiplier = None
        self._rolling_corr = None
    
    def _compute_multiplier(self) -> pd.Series:
        """Compute 1/sqrt(w' * Corr * w) as rolling time series."""
        ws_node = self.predecessor
        weights = ws_node._weights
        
        # Get pnls from WeightedSumNode's predecessors
        pnl_df = pd.DataFrame({
            pred.name: pred.pnl()[pred.name]
            for pred in ws_node.predecessors
        })
        
        # Get weights as array in same order as columns
        w = np.array([weights[name] for name in pnl_df.columns])
        
        # Store rolling correlations
        self._rolling_corr = {}
        
        divisor = pd.Series(index=pnl_df.index, dtype=float)
        
        for i in range(self._window, len(pnl_df)):
            date = pnl_df.index[i]
            window = pnl_df.iloc[i - self._window:i]
            corr = window.corr()
            self._rolling_corr[date] = corr
            wcw = w @ corr.values @ w
            divisor.iloc[i] = np.sqrt(wcw)
        
        multiplier = 1 / divisor
        return multiplier
    
    @property
    def multiplier(self) -> pd.Series:
        """Lazy computation of multiplier. Overrides parent."""
        if self._computed_multiplier is None:
            self._computed_multiplier = self._compute_multiplier()
        return self._computed_multiplier
    
    def get_correlation(self, date=None) -> pd.DataFrame:
        """Get correlation matrix at a specific date, or latest if None."""
        # Ensure computed
        _ = self.multiplier
        
        if date is None:
            date = max(self._rolling_corr.keys())
        return self._rolling_corr[date]
    
    def correlation_series(self, asset1: str = None, asset2: str = None) -> pd.Series:
        """
        Get rolling pairwise correlation as time series.
        
        If asset1 and asset2 not specified, returns first off-diagonal (for 2-asset case).
        """
        # Ensure computed
        _ = self.multiplier
        
        dates = sorted(self._rolling_corr.keys())
        
        if asset1 is None or asset2 is None:
            # Default: first off-diagonal
            corrs = [self._rolling_corr[d].iloc[0, 1] for d in dates]
        else:
            corrs = [self._rolling_corr[d].loc[asset1, asset2] for d in dates]
        
        return pd.Series(corrs, index=dates)
