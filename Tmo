# src/portfolio_tree/visualize.py

from .NodeRegistry import NodeRegistry


def show_tree(node_name: str, direction: str = "down", depth: int = None, show_types: bool = True):
    """
    Print text tree from a node (left to right flow).
    
    Args:
        node_name: Starting node
        direction: "down" (predecessors), "up" (successors), "both"
        depth: Max levels to show (None = all)
        show_types: Show node type in brackets
    """
    node = NodeRegistry.get(node_name)
    
    if direction == "both":
        print("=== Ancestors (what this feeds into) ===")
        _print_ancestors(node_name, show_types, depth)
        print(f"\n=== {node_name} ===\n")
        print("=== Descendants (what feeds into this) ===")
        _print_tree_horizontal(node, show_types, depth)
    elif direction == "up":
        _print_ancestors(node_name, show_types, depth)
    else:  # down
        _print_tree_horizontal(node, show_types, depth)


def _print_tree_horizontal(node, show_types: bool, max_depth: int):
    """Print tree with predecessors on left, node on right."""
    lines = []
    _build_horizontal_tree(node, lines, show_types, max_depth, 0)
    
    # Find the rightmost node position for alignment
    for line in lines:
        print(line)


def _build_horizontal_tree(node, lines: list, show_types: bool, max_depth: int, current_depth: int) -> list[int]:
    """
    Build horizontal tree recursively.
    Returns list of line indices where this node's outputs connect.
    """
    if max_depth is not None and current_depth > max_depth:
        type_str = f" [{NodeRegistry.get_metadata(node.name)['type']}]" if show_types else ""
        lines.append(f"{node.name}{type_str} ...")
        return [len(lines) - 1]
    
    type_str = f" [{NodeRegistry.get_metadata(node.name)['type']}]" if show_types else ""
    node_label = f"{node.name}{type_str}"
    
    # Base case: no predecessors
    if not node.predecessors:
        lines.append(node_label)
        return [len(lines) - 1]
    
    # Recursive case: get all predecessor trees
    pred_line_indices = []
    for pred in node.predecessors:
        indices = _build_horizontal_tree(pred, lines, show_types, max_depth, current_depth + 1)
        pred_line_indices.extend(indices)
    
    # Find middle line for connection
    if pred_line_indices:
        mid_idx = pred_line_indices[len(pred_line_indices) // 2]
        
        # Add arrows to predecessor lines
        for i, idx in enumerate(pred_line_indices):
            if idx < len(lines):
                if i == 0 and len(pred_line_indices) > 1:
                    lines[idx] = lines[idx] + " ──┐"
                elif i == len(pred_line_indices) - 1 and len(pred_line_indices) > 1:
                    lines[idx] = lines[idx] + " ──┘"
                elif i == len(pred_line_indices) // 2:
                    lines[idx] = lines[idx] + " ──┼── " + node_label
                else:
                    lines[idx] = lines[idx] + " ──┤"
        
        # Add vertical connectors between first and last predecessor
        if len(pred_line_indices) > 1:
            max_len = max(len(lines[idx].split("──")[0]) for idx in pred_line_indices)
            for idx in range(pred_line_indices[0] + 1, pred_line_indices[-1]):
                if idx not in pred_line_indices:
                    lines[idx] = lines[idx].ljust(max_len) + "   │"
    
    return [pred_line_indices[len(pred_line_indices) // 2]] if pred_line_indices else []


def show_tree_simple(node_name: str, depth: int = None, show_types: bool = True):
    """
    Simple left-to-right ASCII tree.
    
    Example output:
    LN1 Comdty ─────────────────────────────────┐
    LN1 Comdty_trend_v3_EMA005 ──┐              │
    LN1 Comdty ──────────────────┼── LN1 Comdty_fast_ws ──┐
    LN1 Comdty_trend_v3_EMA010 ──┘                        │
                                                          ├── oil_complex_fast_ws ── oil_complex_fast
    CO1 Comdty ─────────────────────────────────┐         │
    CO1 Comdty_trend_v3_EMA005 ──┐              │         │
    CO1 Comdty ──────────────────┼── CO1 Comdty_fast_ws ──┘
    CO1 Comdty_trend_v3_EMA010 ──┘
    """
    node = NodeRegistry.get(node_name)
    tree_lines = _build_simple_tree(node, show_types, depth, 0)
    print("\n".join(tree_lines))


def _build_simple_tree(node, show_types: bool, max_depth: int, current_depth: int) -> list[str]:
    """Build simple tree returning list of lines."""
    
    type_str = f" [{_short_type(node.name)}]" if show_types else ""
    node_label = f"{node.name}{type_str}"
    
    # Check depth
    if max_depth is not None and current_depth > max_depth:
        return [node_label + " ..."]
    
    # Base case: no predecessors (leaf)
    if not node.predecessors:
        return [node_label]
    
    # Single predecessor: simple arrow
    if len(node.predecessors) == 1:
        pred_lines = _build_simple_tree(node.predecessors[0], show_types, max_depth, current_depth + 1)
        # Append arrow to last line
        pred_lines[-1] = pred_lines[-1] + " ── " + node_label
        return pred_lines
    
    # Multiple predecessors: branching
    all_pred_lines = []
    for i, pred in enumerate(node.predecessors):
        pred_lines = _build_simple_tree(pred, show_types, max_depth, current_depth + 1)
        all_pred_lines.append(pred_lines)
    
    # Combine with branching
    result = []
    total_preds = len(all_pred_lines)
    mid_point = total_preds // 2
    
    for i, pred_lines in enumerate(all_pred_lines):
        for j, line in enumerate(pred_lines):
            if j == len(pred_lines) - 1:  # Last line of this predecessor
                if i == 0:
                    result.append(line + " ──┐")
                elif i == total_preds - 1:
                    result.append(line + " ──┘")
                elif i == mid_point:
                    result.append(line + " ──┼── " + node_label)
                else:
                    result.append(line + " ──┤")
            else:
                result.append(line)
        
        # Add spacer between predecessors (except last)
        if i < total_preds - 1 and i != mid_point - 1:
            # Find max line length for alignment
            max_len = max(len(l.rstrip()) for l in result) if result else 0
            result.append(" " * max_len + "   │")
    
    return result


def _short_type(node_name: str) -> str:
    """Get shortened type name."""
    meta = NodeRegistry.get_metadata(node_name)
    type_map = {
        "InstrumentNode": "Instr",
        "PrecomputedUVTrendSignalNode": "Signal",
        "WeightedSumNode": "WSum",
        "ScalingNode": "Scale",
        "CorrAdjustedUVScalingNode": "CorrUV"
    }
    return type_map.get(meta["type"], meta["type"])


def _print_ancestors(node_name: str, show_types: bool, max_depth: int):
    """Find and print nodes that have this node as predecessor."""
    
    successors = []
    for name in NodeRegistry.list_nodes():
        meta = NodeRegistry.get_metadata(name)
        if node_name in meta["predecessors"]:
            successors.append(name)
    
    if not successors:
        print(f"(no nodes use {node_name} as input)")
        return
    
    for succ_name in successors:
        type_str = f" [{_short_type(succ_name)}]" if show_types else ""
        print(f"→ {succ_name}{type_str}")
        
        if max_depth is None or max_depth > 1:
            sub_ancestors = _get_ancestors(succ_name, max_depth - 1 if max_depth else None)
            for anc in sub_ancestors:
                type_str = f" [{_short_type(anc)}]" if show_types else ""
                print(f"  → {anc}{type_str}")


def _get_ancestors(node_name: str, max_depth: int) -> list[str]:
    """Get list of nodes that use this node as input."""
    if max_depth is not None and max_depth <= 0:
        return []
    
    ancestors = []
    for name in NodeRegistry.list_nodes():
        meta = NodeRegistry.get_metadata(name)
        if node_name in meta["predecessors"]:
            ancestors.append(name)
            ancestors.extend(_get_ancestors(name, max_depth - 1 if max_depth else None))
    
    return ancestors


def tree_to_mermaid(node_name: str, depth: int = None) -> str:
    """
    Generate Mermaid diagram code (left to right flow).
    
    Usage in notebook:
        from IPython.display import display, Markdown
        display(Markdown(f"```mermaid\\n{tree_to_mermaid('node_name')}\\n```"))
    """
    lines = ["graph LR"]  # LR = left to right
    visited = set()
    
    node = NodeRegistry.get(node_name)
    _build_mermaid(node, lines, visited, depth, 0)
    
    return "\n".join(lines)


def _build_mermaid(node, lines: list, visited: set, max_depth: int, current_depth: int):
    """Recursively build mermaid graph."""
    
    if max_depth is not None and current_depth > max_depth:
        return
    
    if node.name in visited:
        return
    visited.add(node.name)
    
    # Sanitize node name for mermaid
    safe_name = node.name.replace(" ", "_").replace("-", "_")
    short_type = _short_type(node.name)
    
    for pred in node.predecessors:
        safe_pred = pred.name.replace(" ", "_").replace("-", "_")
        pred_type = _short_type(pred.name)
        # Arrow from predecessor to node (left to right)
        lines.append(f"    {safe_pred}[{pred.name}<br/>{pred_type}] --> {safe_name}[{node.name}<br/>{short_type}]")
        _build_mermaid(pred, lines, visited, max_depth, current_depth + 1)
