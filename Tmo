import numpy as np

def t_bridge_match_std_simple(
    p0, p1, n_steps, sigma_target, nu, T=1.0, seed=123, ddof=1
):
    """
    Student-t style bridge between p0 and p1 whose *simple returns*
    have sample std â‰ˆ sigma_target (not exploding under exp()).
    """
    rng = np.random.default_rng(seed)
    X0, X1 = np.log(p0), np.log(p1)
    total_lr = X1 - X0
    m = total_lr / n_steps

    # Heavy-tailed random shocks (Student-t via scale mixture)
    g = rng.chisquare(df=nu)
    s_mix = np.sqrt(nu / g)
    eps = rng.standard_normal(n_steps)
    u = s_mix * eps
    u -= u.mean()               # zero-sum noise
    # baseline linear bridge in log space
    base_lr = m + 0.05 * u      # small perturbation

    # build baseline prices
    X = X0 + np.cumsum(np.concatenate([[0], base_lr]))
    P = np.exp(X)
    r = P[1:] / P[:-1] - 1.0
    std0 = np.std(r, ddof=ddof)
    if std0 == 0:
        return np.linspace(0, T, n_steps + 1), np.linspace(p0, p1, n_steps + 1), {}

    # rescale *returns*, not log deviations
    k = sigma_target / std0
    r_scaled = r * k
    # renormalize to exact endpoint
    adj = (p1 / p0) / np.prod(1 + r_scaled)
    r_scaled[-1] = adj * (1 + r_scaled[-1]) - 1
    # rebuild prices
    P2 = np.empty(n_steps + 1)
    P2[0] = p0
    for i in range(n_steps):
        P2[i + 1] = P2[i] * (1 + r_scaled[i])

    achieved = np.std(P2[1:] / P2[:-1] - 1, ddof=ddof)
    return np.linspace(0, T, n_steps + 1), P2, {"std_achieved": achieved, "scale_k": k}