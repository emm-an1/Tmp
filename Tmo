################################################################################
# FILE: src/portfolio_tree/NodeRegistry.py
################################################################################

class NodeRegistry:
    """Registry to look up nodes by name."""
    
    _nodes = {}  # {name: node}
    _metadata = {}  # {name: {type, predecessors, ...}}
    
    @classmethod
    def register(cls, node):
        """Register a node. Called automatically on node creation."""
        if node.name in cls._nodes:
            raise ValueError(f"Node with name '{node.name}' already exists.")
        
        cls._nodes[node.name] = node
        cls._metadata[node.name] = {
            "type": node.__class__.__name__,
            "predecessors": [p.name for p in node.predecessors],
            "n_predecessors": len(node.predecessors),
            "instruments": node.instruments() if hasattr(node, 'instruments') else []
        }
    
    @classmethod
    def get(cls, name: str):
        """Get a node by name."""
        if name not in cls._nodes:
            raise KeyError(f"Node '{name}' not found. Available: {list(cls._nodes.keys())}")
        return cls._nodes[name]
    
    @classmethod
    def get_metadata(cls, name: str) -> dict:
        """Get metadata for a node."""
        if name not in cls._metadata:
            raise KeyError(f"Node '{name}' not found.")
        return cls._metadata[name]
    
    @classmethod
    def find(cls, pattern: str, node_type: str = None) -> list[str]:
        """
        Find nodes by partial name match.
        
        Args:
            pattern: Substring to search for (case-insensitive)
            node_type: Optional filter by node type (e.g., "InstrumentNode", "WeightedSumNode")
        
        Returns:
            List of matching node names
        """
        matches = []
        pattern_lower = pattern.lower()
        
        for name, meta in cls._metadata.items():
            # Check pattern match
            if pattern_lower not in name.lower():
                continue
            
            # Check type filter
            if node_type is not None and meta["type"] != node_type:
                continue
            
            matches.append(name)
        
        return sorted(matches)
    
    @classmethod
    def find_by_type(cls, node_type: str) -> list[str]:
        """Find all nodes of a specific type."""
        return [name for name, meta in cls._metadata.items() if meta["type"] == node_type]
    
    @classmethod
    def find_by_instrument(cls, instrument: str) -> list[str]:
        """Find all nodes that involve a specific instrument."""
        return [name for name, meta in cls._metadata.items() if instrument in meta["instruments"]]
    
    @classmethod
    def clear(cls):
        """Clear all registered nodes. Useful for testing."""
        cls._nodes = {}
        cls._metadata = {}
    
    @classmethod
    def list_nodes(cls):
        """List all registered node names."""
        return list(cls._nodes.keys())
    
    @classmethod
    def summary(cls) -> dict:
        """Return summary of registered nodes by type."""
        type_counts = {}
        for meta in cls._metadata.values():
            t = meta["type"]
            type_counts[t] = type_counts.get(t, 0) + 1
        return type_counts
