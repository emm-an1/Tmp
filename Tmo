from typing import Union
import pandas as pd

from .base import Node


class ScalingNode(Node):
    """
    Scales predecessor's market values by a multiplier.
    
    mv() = predecessor.mv() * multiplier
    
    Note: Always multiplies. To divide by X, pass 1/X as multiplier.
    """
    
    def __init__(self, name: str, predecessors: list[str], multiplier: Union[pd.Series, pd.DataFrame] = None):
        """
        Args:
            name: Node name
            predecessors: List with single predecessor name
            multiplier: Series (applied to all instruments) or DataFrame (per instrument).
                        Can be None if subclass computes it.
        """
        super().__init__(name=name, predecessors=predecessors)
        
        if len(self.predecessors) != 1:
            raise ValueError(f"ScalingNode expects 1 predecessor, got {len(self.predecessors)}")
        
        self._multiplier = multiplier
    
    @property
    def predecessor(self) -> Node:
        """Convenience accessor for single predecessor."""
        return self.predecessors[0]
    
    @property
    def multiplier(self) -> Union[pd.Series, pd.DataFrame]:
        """Multiplier. Override in subclass for computed multipliers."""
        if self._multiplier is None:
            raise ValueError("Multiplier not set. Override multiplier property in subclass.")
        return self._multiplier
    
    def mv(self) -> pd.DataFrame:
        """
        Returns scaled market values.
        
        mv = predecessor.mv() * multiplier
        
        Index: date
        Columns: one column per instrument.
        """
        pred_mv = self.predecessor.mv()
        
        if isinstance(self.multiplier, pd.Series):
            result = pred_mv.multiply(self.multiplier, axis=0)
        else:
            result = pred_mv * self.multiplier
        
        return result
    
    def mv_detail(self) -> pd.DataFrame:
        """
        Returns disaggregated market values.
        
        For ScalingNode, same as mv() but with predecessor name prefix.
        """
        mv = self.mv()
        mv.columns = [f"{self.predecessor.name}.{col}" for col in mv.columns]
        return mv
    
    def pnl(self) -> pd.DataFrame:
        """
        Returns aggregated pnl for this node.
        
        pnl(t) = mv(t-1) * r(t-1, t)
        
        Index: date
        Columns: single column named after this node.
        """
        mv = self.mv()
        returns = self.instrument_returns()
        
        instruments = [c for c in mv.columns if c in returns.columns]
        
        total_pnl = pd.Series(0.0, index=mv.index)
        for instrument in instruments:
            total_pnl += mv[instrument].shift(1) * returns[instrument]
        
        result = pd.DataFrame({self.name: total_pnl})
        return result
