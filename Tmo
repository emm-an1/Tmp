import numpy as np
from scipy.stats import t as student_t

def t_bridge_simple_returns(
    p0: float,
    p1: float,
    n_steps: int,
    sigma_target: float,
    nu: float,
    seed: int = 123,
    max_iter: int = 20,
    tol: float = 1e-8,
):
    """
    Robust Student-t bridge whose *simple returns* have sample std â‰ˆ sigma_target
    and endpoints exactly at p0, p1.
    """
    rng = np.random.default_rng(seed)
    ratio = p1 / p0
    N = n_steps

    # initial mean return per step that reaches p1/p0 if all equal
    a = ratio ** (1 / N) - 1.0
    # sample from Student-t (mean 0, std 1)
    z = student_t.rvs(df=nu, size=N, random_state=rng)
    z -= z.mean()

    # start with scale b giving approximate target std
    b = sigma_target / np.std(z)

    for _ in range(max_iter):
        r = a + b * z
        # enforce positivity to avoid numeric blowups
        if np.any(1 + r <= 0):
            b *= 0.9
            continue

        # endpoint product
        prod_ratio = np.prod(1 + r)
        err_ratio = ratio / prod_ratio
        if abs(err_ratio - 1) < tol:
            break
        # adjust mean component a multiplicatively
        a = (1 + a) * err_ratio ** (1 / N) - 1

        # small rescale of b to keep std near target
        std_r = np.std(r)
        if std_r > 0:
            b *= sigma_target / std_r

    # final path
    P = np.empty(N + 1)
    P[0] = p0
    for i in range(N):
        P[i + 1] = P[i] * (1 + a + b * z[i])

    achieved_std = np.std(P[1:] / P[:-1] - 1)
    return np.linspace(0, 1, N + 1), P, {
        "achieved_std": achieved_std,
        "a": a,
        "b": b,
        "nu": nu
    }