import numpy as np
from scipy.optimize import curve_fit

def smooth_sigmoid(df, x_col='x', y_col='y'):
    x = df[x_col].values
    y = df[y_col].values
    
    # Detect direction
    slope = np.polyfit(x, y, 1)[0]
    increasing = slope > 0
    
    def sigmoid(x, a, b, c, d):
        # a = lower asymptote, d = upper asymptote
        # b = steepness, c = midpoint
        return a + (d - a) / (1 + np.exp(-b * (x - c)))
    
    # Initial guesses
    y_min, y_max = y.min(), y.max()
    x_mid = x.mean()
    b0 = 1 if increasing else -1
    p0 = [y_min, b0, x_mid, y_max]
    
    # Bounds to enforce direction
    if increasing:
        bounds = ([-np.inf, 0, -np.inf, -np.inf], 
                  [np.inf, np.inf, np.inf, np.inf])
    else:
        bounds = ([-np.inf, -np.inf, -np.inf, -np.inf], 
                  [np.inf, 0, np.inf, np.inf])
    
    popt, _ = curve_fit(sigmoid, x, y, p0=p0, bounds=bounds, maxfev=5000)
    y_smooth = sigmoid(x, *popt)
    
    result = df.copy()
    result[f'{y_col}_smooth'] = y_smooth
    return result
