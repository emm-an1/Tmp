import numpy as np

def brownian_bridge(p0, pT, n, sigma=0.01, match_vol=True, max_iter=10, tol=0.01):
    """
    Generate a Brownian bridge from p0 to pT.
    
    Parameters:
        p0: starting price
        pT: ending price  
        n: number of steps (returns n+1 points)
        sigma: target per-step return volatility
        match_vol: if True, inflate sigma iteratively to match target vol
        max_iter: max calibration iterations
        tol: acceptable relative error in vol matching
    
    Returns:
        numpy array of length n+1
    """
    if p0 <= 0 or pT <= 0:
        raise ValueError("Prices must be positive")
    
    def generate_path(sig):
        t = np.linspace(0, 1, n + 1)
        dW = np.random.randn(n)
        W = np.concatenate([[0], np.cumsum(dW)])
        bridge = W - t * W[-1]
        path = p0 + (pT - p0) * t + sig * p0 * bridge
        path = np.abs(path)
        path[0], path[-1] = p0, pT
        return path
    
    if not match_vol:
        return generate_path(sigma)
    
    # Iterative calibration
    sig_adj = sigma
    for _ in range(max_iter):
        # Average over a few paths to get stable vol estimate
        vols = []
        for _ in range(20):
            path = generate_path(sig_adj)
            rets = np.diff(path) / path[:-1]
            vols.append(rets.std())
        realized_vol = np.mean(vols)
        
        error = (sigma - realized_vol) / sigma
        if abs(error) < tol:
            break
        
        # Adjust proportionally
        sig_adj *= sigma / realized_vol
    
    return generate_path(sig_adj)
