################################################################################
# HIERARCHICAL GROUP CREATION FROM EXCEL
################################################################################
"""
# Example groups.xlsx structure:
# | instrument | level_1    | level_2      | level_3 |
# |------------|------------|--------------|---------|
# | NO1 Index  | JP_equity  | Asia_equity  | Equity  |
# | TP1 Index  | JP_equity  | Asia_equity  | Equity  |
# | HSI Index  | HK_equity  | Asia_equity  | Equity  |
# | ES1 Index  | US_equity  | DM_equity    | Equity  |
# | NQ1 Index  | US_equity  | DM_equity    | Equity  |

import pandas as pd
from collections import defaultdict

def create_group_nodes(groups_df: pd.DataFrame, speed: str, years: float = 5):
    '''
    Create hierarchical group nodes from Excel mapping.
    
    Args:
        groups_df: DataFrame with columns [instrument, level_1, level_2, ...]
        speed: "fast", "medium", or "slow"
        years: Rolling window for correlation scaling
    '''
    # Get level columns (all except 'instrument')
    level_cols = [c for c in groups_df.columns if c != 'instrument']
    
    # Process each level from left to right
    for level_idx, level_col in enumerate(level_cols):
        
        # Get unique groups at this level
        groups = groups_df[level_col].dropna().unique()
        
        for group_name in groups:
            # Get members for this group
            if level_idx == 0:
                # First level: members are instrument nodes
                members = groups_df[groups_df[level_col] == group_name]['instrument'].tolist()
                pred_names = [f"{m}_{speed}" for m in members]
            else:
                # Higher levels: members are previous level groups
                prev_level_col = level_cols[level_idx - 1]
                members = groups_df[groups_df[level_col] == group_name][prev_level_col].dropna().unique().tolist()
                pred_names = [f"{m}_{speed}" for m in members]
            
            # Skip if only one member (no aggregation needed)
            if len(pred_names) <= 1:
                continue
            
            # Check all predecessors exist
            missing = [p for p in pred_names if p not in NodeRegistry.list_nodes()]
            if missing:
                print(f"Skipping {group_name}_{speed}: missing predecessors {missing}")
                continue
            
            # Create weighted sum (equal weights)
            weights = {name: 1.0 for name in pred_names}
            ws_name = f"{group_name}_{speed}_ws"
            
            WeightedSumNode(
                name=ws_name,
                predecessors=pred_names,
                weights=weights
            )
            
            # Create correlation-adjusted scaling
            CorrAdjustedUVScalingNode(
                name=f"{group_name}_{speed}",
                predecessors=[ws_name],
                years=years
            )
            
            print(f"Created {group_name}_{speed}")

# Usage:
# groups_df = pd.read_excel("config/groups.xlsx")
# for speed in ["fast", "medium", "slow"]:
#     create_group_nodes(groups_df, speed)
"""