import numpy as np

def brownian_bridge(p0, pT, n, sigma=None):
    """
    Generate a Brownian bridge path from p0 to pT in n steps.
    
    Parameters:
        p0: starting price
        pT: ending price
        n: number of steps (returns n+1 points including endpoints)
        sigma: volatility scaling (default: auto-scaled based on price movement)
    
    Returns:
        numpy array of length n+1 with path from p0 to pT
    """
    if p0 <= 0 or pT <= 0:
        raise ValueError("Start and end prices must be positive")
    
    if sigma is None:
        # Default sigma scaled to price level and path length
        sigma = 0.1 * min(p0, pT) / np.sqrt(n)
    
    # Time grid
    t = np.linspace(0, 1, n + 1)
    
    # Generate standard Brownian motion increments
    dW = np.random.randn(n) * np.sqrt(1/n)
    W = np.concatenate([[0], np.cumsum(dW)])
    
    # Brownian bridge transformation: B(t) = W(t) - t*W(1)
    # This gives a process that starts and ends at 0
    bridge = W - t * W[-1]
    
    # Linear interpolation from p0 to pT, plus scaled bridge noise
    path = p0 + (pT - p0) * t + sigma * np.sqrt(n) * bridge
    
    # Enforce positive prices via reflection
    path = np.abs(path)
    path[path == 0] = 1e-6  # avoid exact zeros
    
    # Force exact endpoints
    path[0] = p0
    path[-1] = pT
    
    return path
