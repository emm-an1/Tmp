import numpy as np

def brownian_bridge(p0, pT, n, sigma=0.01, tol=0.1, max_attempts=1000):
    """
    Generate a Brownian bridge from p0 to pT with target volatility.
    
    Parameters:
        p0: starting price
        pT: ending price  
        n: number of steps (returns n+1 points)
        sigma: target per-step return volatility
        tol: acceptable relative error (0.1 = within 10% of target vol)
        max_attempts: max paths to try before giving up
    
    Returns:
        numpy array of length n+1
    """
    if p0 <= 0 or pT <= 0:
        raise ValueError("Prices must be positive")
    
    t = np.linspace(0, 1, n + 1)
    
    for attempt in range(max_attempts):
        dW = np.random.randn(n)
        W = np.concatenate([[0], np.cumsum(dW)])
        bridge = W - t * W[-1]
        
        path = p0 + (pT - p0) * t + sigma * p0 * bridge
        path = np.abs(path)
        path[0], path[-1] = p0, pT
        
        rets = np.diff(path) / path[:-1]
        realized_vol = rets.std()
        
        rel_error = abs(realized_vol - sigma) / sigma
        if rel_error <= tol:
            return path
    
    raise RuntimeError(f"Could not match target vol within {max_attempts} attempts")
